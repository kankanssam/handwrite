<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì†ê¸€ì”¨ ì—°ìŠµì¥ - ê¸€ê¼´ ë° ì˜ì—­ ì œí•œ ìµœì í™”</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&family=Nanum+Gothic+Coding&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gaegu&display=swap" rel="stylesheet">
    <style>
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: 'Nanum Gothic', sans-serif;
            overflow: hidden;
        }
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #f9fafb;
            -webkit-overflow-scrolling: touch;
        }
        canvas {
            display: block;
            touch-action: none;
            background-color: transparent;
        }
        .grid-layer {
            position: absolute;
            top: 0; left: 0;
            pointer-events: none;
            user-select: none;
        }
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5); z-index: 100; justify-content: center; align-items: center;
        }
        #resultToast {
            position: fixed; bottom: 20px; right: 20px; padding: 1rem 2rem;
            background: #1f2937; color: white; border-radius: 0.5rem;
            display: none; z-index: 50;
        }
        footer {
            background: rgba(255, 255, 255, 0.8); border-top: 1px solid #e5e7eb; padding: 0.5rem;
            text-align: center; font-size: 0.75rem; color: #6b7280;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col md:flex-row">

    <aside class="w-full md:w-1/5 bg-white shadow-xl p-6 z-10 flex flex-col gap-5 overflow-y-auto border-r border-gray-200 h-screen">
        <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
            <span class="text-2xl">ğŸ–‹ï¸</span> ì†ê¸€ì”¨ ì—°ìŠµì¥
        </h1>
        
        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">ì—°ìŠµí•  ë¬¸ì¥</label>
            <textarea id="inputText" class="w-full p-3 border border-gray-300 rounded-lg outline-none resize-none" rows="3">ì •ë³´ ë° ì¸ê³µì§€ëŠ¥ê¸°ì´ˆ êµê³¼í•™ìŠµì„ ìœ„í•œ ì†ê¸€ì”¨ ì“°ê¸°.</textarea>
        </div>

        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">ê¸€ê¼´ ì„ íƒ</label>
            <select id="fontSelect" class="w-full p-2 border border-gray-300 rounded-lg outline-none">
                <option value="'Nanum Gothic', sans-serif">ë‹ì›€</option>
                <option value="'Nanum Gothic Coding', monospace">êµ´ë¦¼</option>
                <option value="'Nanum Pen Script', cursive">í•„ê¸°ì²´</option>
                <option value="'Nanum Myeongjo', serif">ê¶ì„œì²´</option>
                <option value="'Gaegu', cursive">ëŒ€ë‚˜ë¬´</option>
            </select>
        </div>

        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">íœ ì„¤ì •</label>
            <div class="flex items-center gap-2">
                <input type="color" id="customColor" class="w-10 h-10 p-0 border-none bg-transparent cursor-pointer" value="#1a56db">
                <input type="range" id="strokeRange" min="2" max="15" value="6" class="flex-grow accent-blue-600">
            </div>
        </div>

        <div class="mt-4 flex flex-col gap-2">
            <button id="analyzeBtn" class="w-full py-4 bg-green-600 text-white font-bold rounded-xl shadow-lg">ğŸ¯ íŒì • ë° ê²°ê³¼ ê¸°ë¡</button>
            <div class="grid grid-cols-3 gap-2">
                <button id="undoBtn" class="py-2 bg-amber-50 text-amber-600 font-semibold rounded-lg border border-amber-200 text-xs text-center">ë˜ëŒë¦¬ê¸°</button>
                <button id="clearBtn" class="py-2 bg-gray-100 text-gray-600 font-semibold rounded-lg text-xs text-center">ì§€ìš°ê¸°</button>
                <button id="downloadBtn" class="py-2 bg-blue-50 text-blue-600 font-semibold rounded-lg text-xs text-center">ì €ì¥</button>
            </div>
        </div>

        <div id="scoreDisplay" class="hidden mt-4 p-4 bg-blue-50 border border-blue-100 rounded-xl text-center">
            <p class="text-sm text-blue-600 font-medium">í˜„ì¬ ì¼ì¹˜ìœ¨</p>
            <p id="percentVal" class="text-3xl font-black text-blue-700">0%</p>
        </div>
    </aside>

    <main class="flex-grow relative overflow-hidden h-screen flex flex-col">
        <div id="canvas-container">
            <canvas id="guideCanvas" class="grid-layer"></canvas>
            <canvas id="paintCanvas"></canvas>
        </div>
        <footer>
            <p>Â© 2024. <strong>ê¹ê¹ìŒ¤</strong> All rights reserved.</p>
        </footer>
    </main>

    <div id="infoModal" class="modal">
        <div class="bg-white p-8 rounded-2xl shadow-2xl w-96 flex flex-col gap-4">
            <h2 class="text-xl font-bold text-gray-800 text-center">ì—°ìŠµ ê²°ê³¼ ê¸°ë¡</h2>
            <p id="modalScoreText" class="text-center text-blue-600 font-bold text-lg mb-2"></p>
            <input type="text" id="studentId" class="w-full p-3 border border-gray-300 rounded-lg outline-none" placeholder="í•™ë²ˆ(ì˜ˆ: 20101)">
            <input type="text" id="studentName" class="w-full p-3 border border-gray-300 rounded-lg outline-none" placeholder="ì´ë¦„(ì˜ˆ: í™ê¸¸ë™)">
            <div class="flex gap-2 mt-4">
                <button id="cancelModal" class="flex-1 py-3 bg-gray-100 text-gray-600 font-bold rounded-lg">ì·¨ì†Œ</button>
                <button id="submitInfo" class="flex-1 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-md">
                    <span id="btnText">ì‹œíŠ¸ì— ê¸°ë¡í•˜ê¸°</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        const scriptURL = "https://script.google.com/macros/s/AKfycbzClrwGAApEdUwU3hxIrKhOOTXtVZo0jBRuiW4OJ4mm4q-b1hWt8EM_M989wq_KF0dT/exec";
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const guideCanvas = document.getElementById('guideCanvas');
        const gCtx = guideCanvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        
        const inputText = document.getElementById('inputText');
        const fontSelect = document.getElementById('fontSelect');
        const strokeRange = document.getElementById('strokeRange');
        const customColor = document.getElementById('customColor');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');

        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let currentAccuracy = 0;
        const cellSize = 140, padding = 30, lineSpacing = 40;
        
        let history = [];
        function saveHistory() {
            if (history.length > 20) history.shift();
            history.push(canvas.toDataURL());
        }

        function undo() {
            if (history.length === 0) return;
            let img = new Image();
            img.src = history.pop();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
        }

        function getCharsPerLine() {
            const containerWidth = container.clientWidth - (padding * 2);
            return Math.max(1, Math.floor(containerWidth / cellSize));
        }

        function isInsideWriteArea(x, y) {
            const text = inputText.value.replace(/\n/g, "");
            const charsPerLine = getCharsPerLine();
            for (let i = 0; i < text.length; i++) {
                const lineIndex = Math.floor(i / charsPerLine);
                const charIndexInLine = i % charsPerLine;
                const rectX = padding + (charIndexInLine * cellSize);
                const rectY = padding + (lineIndex * ((cellSize * 2) + lineSpacing)) + cellSize; 
                
                if (x >= rectX && x <= rectX + cellSize && y >= rectY && y <= rectY + cellSize) {
                    return true;
                }
            }
            return false;
        }

        function initCanvas() {
            const charsPerLine = getCharsPerLine();
            const text = inputText.value.replace(/\n/g, "");
            const totalLines = Math.ceil(text.length / charsPerLine);
            const unitHeight = (cellSize * 2) + lineSpacing;
            const width = container.clientWidth;
            const height = Math.max(container.clientHeight, (unitHeight * totalLines) + (padding * 2));
            
            const temp = canvas.toDataURL();
            canvas.width = width; canvas.height = height;
            guideCanvas.width = width; guideCanvas.height = height;
            
            drawGuides(charsPerLine);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            let img = new Image();
            img.src = temp;
            img.onload = () => ctx.drawImage(img, 0, 0);
        }

        function drawGuides(charsPerLine) {
            gCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            const text = inputText.value.replace(/\s/g, " ");
            const font = fontSelect.value;
            for (let i = 0; i < text.length; i++) {
                const lineIndex = Math.floor(i / charsPerLine);
                const charIndexInLine = i % charsPerLine;
                const x = padding + (charIndexInLine * cellSize);
                const yOffset = padding + (lineIndex * ((cellSize * 2) + lineSpacing));
                
                gCtx.strokeStyle = '#d1d5db'; gCtx.setLineDash([]); gCtx.strokeRect(x, yOffset, cellSize, cellSize);
                gCtx.strokeRect(x, yOffset + cellSize, cellSize, cellSize);
                
                gCtx.beginPath(); gCtx.setLineDash([3, 3]); gCtx.strokeStyle = '#e5e7eb';
                const step = cellSize / 2;
                gCtx.moveTo(x + step, yOffset + cellSize); gCtx.lineTo(x + step, yOffset + (cellSize * 2));
                gCtx.moveTo(x, yOffset + cellSize + step); gCtx.lineTo(x + cellSize, yOffset + cellSize + step);
                gCtx.stroke();

                gCtx.textAlign = 'center'; gCtx.textBaseline = 'middle';
                gCtx.font = `${cellSize * 0.65}px ${font}`;
                gCtx.fillStyle = '#111827'; gCtx.fillText(text[i], x + cellSize/2, yOffset + cellSize/2);
                gCtx.fillStyle = 'rgba(0,0,0,0.03)'; gCtx.fillText(text[i], x + cellSize/2, yOffset + cellSize*1.5);
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        function startDrawing(e) {
            if (e.touches && e.touches.length > 1) return;
            const p = getPos(e);
            if (isInsideWriteArea(p.x, p.y)) {
                isDrawing = true;
                saveHistory();
                [lastX, lastY] = [p.x, p.y];
            }
        }

        function drawing(e) {
            if (!isDrawing) return;
            const p = getPos(e);
            if (isInsideWriteArea(p.x, p.y)) {
                e.preventDefault(); 
                ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(p.x, p.y);
                ctx.strokeStyle = customColor.value; ctx.lineWidth = strokeRange.value; ctx.stroke();
                [lastX, lastY] = [p.x, p.y];
            } else {
                isDrawing = false;
            }
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', drawing);
        window.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', drawing, { passive: false });
        canvas.addEventListener('touchend', () => isDrawing = false);

        // ë¶„ì„ ë° ê¸°ë¡ (ê¸°ì¡´ ìœ ì§€)
        function analyzeHandwriting() {
            const originalText = inputText.value; if (!originalText.trim()) return;
            const charsPerLine = getCharsPerLine();
            const font = fontSelect.value;
            const offCanvas = document.createElement('canvas');
            offCanvas.width = canvas.width; offCanvas.height = canvas.height;
            const oCtx = offCanvas.getContext('2d');
            oCtx.font = `${cellSize * 0.65}px ${font}`; oCtx.textAlign = 'center'; oCtx.textBaseline = 'middle';
            let totalMatchScore = 0, validChars = 0;
            for (let i = 0; i < originalText.length; i++) {
                const char = originalText[i]; if (char.trim().length === 0) continue;
                const x = padding + ((i % charsPerLine) * cellSize);
                const y = padding + (Math.floor(i / charsPerLine) * ((cellSize * 2) + lineSpacing)) + cellSize;
                oCtx.clearRect(x, y, cellSize, cellSize); oCtx.fillText(char, x + cellSize / 2, y + cellSize / 2);
                const answerData = oCtx.getImageData(x, y, cellSize, cellSize).data;
                const userData = ctx.getImageData(x, y, cellSize, cellSize).data;
                let match = 0, answerPixels = 0, userPixels = 0;
                for (let j = 3; j < answerData.length; j += 4) {
                    if (answerData[j] > 20) answerPixels++;
                    if (userData[j] > 20) userPixels++;
                    if (answerData[j] > 20 && userData[j] > 20) match++;
                }
                if (userPixels > 10) { totalMatchScore += Math.min((match / answerPixels) * 100, 100); validChars++; }
            }
            currentAccuracy = validChars > 0 ? Math.round(totalMatchScore / validChars) : 0;
            document.getElementById('percentVal').textContent = currentAccuracy + '%';
            document.getElementById('scoreDisplay').classList.remove('hidden');
            document.getElementById('modalScoreText').textContent = `í‰ê·  ì •í™•ë„: ${currentAccuracy}%`;
            document.getElementById('infoModal').style.display = 'flex';
        }

        document.getElementById('submitInfo').onclick = async () => {
            const sid = document.getElementById('studentId').value.trim();
            const sname = document.getElementById('studentName').value.trim();
            if (!sid || !sname) { alert("í•™ë²ˆê³¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }
            const btnText = document.getElementById('btnText');
            btnText.innerHTML = 'ê¸°ë¡ ì¤‘...';
            try {
                await fetch(scriptURL, { method: 'POST', mode: 'no-cors', body: JSON.stringify({ studentId: sid, name: sname, text: inputText.value, accuracy: currentAccuracy }) });
                alert("ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!");
                document.getElementById('infoModal').style.display = 'none';
            } catch (e) { alert("ì˜¤ë¥˜ ë°œìƒ"); }
            btnText.innerText = 'ì‹œíŠ¸ì— ê¸°ë¡í•˜ê¸°';
        };

        document.getElementById('cancelModal').onclick = () => document.getElementById('infoModal').style.display = 'none';
        clearBtn.onclick = () => { if(confirm("ì´ˆê¸°í™”?")) { ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; } };
        undoBtn.onclick = undo;
        inputText.oninput = initCanvas;
        fontSelect.onchange = initCanvas;
        window.onresize = initCanvas;
        window.onload = initCanvas;
    </script>
</body>
</html>
