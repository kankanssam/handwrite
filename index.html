<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì†ê¸€ì”¨ ì—°ìŠµì¥ - ìµœì¢… ë³´ì •ë³¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic&family=Nanum+Gothic+Coding&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gaegu&family=Noto+Sans+KR&display=swap" rel="stylesheet">
    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; }
        #canvas-container { position: relative; width: 100%; height: 100%; overflow: auto; background-color: #f9fafb; -webkit-overflow-scrolling: touch; }
        canvas { display: block; touch-action: none; background-color: transparent; }
        .grid-layer { position: absolute; top: 0; left: 0; pointer-events: none; user-select: none; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 100; justify-content: center; align-items: center; }
        #resultToast { position: fixed; bottom: 20px; right: 20px; padding: 1rem 2rem; background: #1f2937; color: white; border-radius: 0.5rem; display: none; z-index: 50; }
        .loading-spinner { border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top: 3px solid #fff; width: 20px; height: 20px; animation: spin 1s linear infinite; display: inline-block; margin-right: 8px; vertical-align: middle; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        footer { position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px); border-top: 1px solid #e5e7eb; padding: 0.5rem; text-align: center; font-size: 0.75rem; color: #6b7280; z-index: 40; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col md:flex-row pb-8">

    <aside class="w-full md:w-1/5 bg-white shadow-xl p-6 z-10 flex flex-col gap-5 overflow-y-auto border-r border-gray-200">
        <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
            <span class="text-2xl">ğŸ–‹ï¸</span> ì†ê¸€ì”¨ ëˆ„ì ê¸°ë¡ ì—°ìŠµì¥
        </h1>
        
        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">ì—°ìŠµí•  ë¬¸ì¥</label>
            <textarea id="inputText" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 outline-none resize-none" rows="3">ì •ë³´ ë° ì¸ê³µì§€ëŠ¥ê¸°ì´ˆ êµê³¼í•™ìŠµì„ ìœ„í•œ ì†ê¸€ì”¨ ì“°ê¸°.</textarea>
        </div>

        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">ê¸€ê¼´ ì„ íƒ</label>
            <select id="fontSelect" class="w-full p-2 border border-gray-300 rounded-lg outline-none">
                <option value="'Nanum Gothic'">ë‹ì›€</option>
                <option value="'Nanum Gothic Coding'">êµ´ë¦¼</option>
                <option value="'Nanum Pen Script'">í•„ê¸°ì²´</option>
                <option value="'Nanum Myeongjo'">ê¶ì„œì²´</option>
                <option value="'Gaegu'">ëŒ€ë‚˜ë¬´</option>
            </select>
        </div>

        <div class="flex flex-col gap-2">
            <label class="text-sm font-semibold text-gray-600">íœ ì„¤ì •</label>
            <div class="flex items-center gap-2">
                <input type="color" id="customColor" class="w-10 h-10 p-0 border-none bg-transparent cursor-pointer" value="#1a56db">
                <input type="range" id="strokeRange" min="2" max="15" value="6" class="flex-grow accent-blue-600">
            </div>
        </div>

        <div class="mt-4 flex flex-col gap-2">
            <button id="analyzeBtn" class="w-full py-4 bg-green-600 text-white font-bold rounded-xl hover:bg-green-700 transition-all shadow-lg transform active:scale-95">ğŸ¯ íŒì • ë° ê²°ê³¼ ê¸°ë¡</button>
            <div class="grid grid-cols-3 gap-2">
                <button id="undoBtn" class="py-2 bg-amber-50 text-amber-600 font-semibold rounded-lg border border-amber-200 text-xs">ë˜ëŒë¦¬ê¸°</button>
                <button id="clearBtn" class="py-2 bg-gray-100 text-gray-600 font-semibold rounded-lg hover:bg-gray-200 text-xs">ì§€ìš°ê¸°</button>
                <button id="downloadBtn" class="py-2 bg-blue-50 text-blue-600 font-semibold rounded-lg hover:bg-blue-100 text-xs">ì €ì¥</button>
            </div>
        </div>

        <div id="scoreDisplay" class="hidden mt-4 p-4 bg-blue-50 border border-blue-100 rounded-xl text-center">
            <p class="text-sm text-blue-600 font-medium">í˜„ì¬ ì¼ì¹˜ìœ¨</p>
            <p id="percentVal" class="text-3xl font-black text-blue-700">0%</p>
        </div>
    </aside>

    <main class="flex-grow relative overflow-hidden">
        <div id="canvas-container">
            <canvas id="guideCanvas" class="grid-layer"></canvas>
            <canvas id="paintCanvas"></canvas>
        </div>
    </main>

    <div id="infoModal" class="modal">
        <div class="bg-white p-8 rounded-2xl shadow-2xl w-96 flex flex-col gap-4">
            <h2 class="text-xl font-bold text-gray-800 text-center">ì—°ìŠµ ê²°ê³¼ ê¸°ë¡</h2>
            <p id="modalScoreText" class="text-center text-blue-600 font-bold text-lg mb-2"></p>
            <div class="flex flex-col gap-1">
                <label class="text-xs font-bold text-gray-500 ml-1">í•™ë²ˆ</label>
                <input type="text" id="studentId" class="w-full p-3 border border-gray-300 rounded-lg outline-none focus:ring-2 focus:ring-blue-500" placeholder="ì˜ˆ: 20101">
            </div>
            <div class="flex flex-col gap-1">
                <label class="text-xs font-bold text-gray-500 ml-1">ì´ë¦„</label>
                <input type="text" id="studentName" class="w-full p-3 border border-gray-300 rounded-lg outline-none focus:ring-2 focus:ring-blue-500" placeholder="ì˜ˆ: í™ê¸¸ë™">
            </div>
            <div class="flex gap-2 mt-4">
                <button id="cancelModal" class="flex-1 py-3 bg-gray-100 text-gray-600 font-bold rounded-lg">ì·¨ì†Œ</button>
                <button id="submitInfo" class="flex-1 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700">
                    <span id="btnText">ì‹œíŠ¸ì— ê¸°ë¡í•˜ê¸°</span>
                </button>
            </div>
        </div>
    </div>

    <div id="resultToast">ì²˜ë¦¬ ì¤‘...</div>
    <footer><p>Â© 2024. <strong>ê¹ê¹ìŒ¤</strong> All rights reserved.</p></footer>

    <script>
        const scriptURL = "https://script.google.com/macros/s/AKfycbzClrwGAApEdUwU3hxIrKhOOTXtVZo0jBRuiW4OJ4mm4q-b1hWt8EM_M989wq_KF0dT/exec";
        const canvas = document.getElementById('paintCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const guideCanvas = document.getElementById('guideCanvas');
        const gCtx = guideCanvas.getContext('2d');
        const container = document.getElementById('canvas-container');
        const inputText = document.getElementById('inputText');
        const fontSelect = document.getElementById('fontSelect');
        const strokeRange = document.getElementById('strokeRange');
        const customColor = document.getElementById('customColor');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const infoModal = document.getElementById('infoModal');
        const submitInfo = document.getElementById('submitInfo');

        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let currentAccuracy = 0;
        const cellSize = 140, padding = 30, lineSpacing = 40;
        let history = [];

        function saveHistory() {
            if (history.length > 20) history.shift();
            history.push(canvas.toDataURL());
        }

        function undo() {
            if (history.length === 0) return;
            let img = new Image();
            img.src = history.pop();
            img.onload = () => { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.drawImage(img, 0, 0); };
        }

        function isInsideWriteArea(x, y) {
            const text = inputText.value.replace(/\n/g, "");
            const containerWidth = container.clientWidth - (padding * 2);
            const charsPerLine = Math.max(1, Math.floor(containerWidth / cellSize));
            for (let i = 0; i < text.length; i++) {
                const lineIndex = Math.floor(i / charsPerLine);
                const charIndexInLine = i % charsPerLine;
                const rectX = padding + (charIndexInLine * cellSize);
                const rectY = padding + (lineIndex * ((cellSize * 2) + lineSpacing)) + cellSize; 
                if (x >= rectX && x <= rectX + cellSize && y >= rectY && y <= rectY + cellSize) return true;
            }
            return false;
        }

        function initCanvas() {
            const containerWidth = container.clientWidth - (padding * 2);
            const charsPerLine = Math.max(1, Math.floor(containerWidth / cellSize));
            const text = inputText.value.replace(/\n/g, "");
            const totalLines = Math.ceil(text.length / charsPerLine);
            const unitHeight = (cellSize * 2) + lineSpacing;
            const temp = canvas.toDataURL();
            canvas.width = container.clientWidth;
            canvas.height = Math.max(container.clientHeight, (unitHeight * totalLines) + (padding * 2));
            guideCanvas.width = canvas.width;
            guideCanvas.height = canvas.height;
            drawGuides(charsPerLine);
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            let img = new Image(); img.src = temp;
            img.onload = () => ctx.drawImage(img, 0, 0);
        }

        function drawGuides(charsPerLine) {
            gCtx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            const text = inputText.value.replace(/\s/g, " ");
            const font = fontSelect.value;
            for (let i = 0; i < text.length; i++) {
                const lineIndex = Math.floor(i / charsPerLine);
                const charIndexInLine = i % charsPerLine;
                const x = padding + (charIndexInLine * cellSize);
                const yOffset = padding + (lineIndex * ((cellSize * 2) + lineSpacing));
                
                gCtx.strokeStyle = '#d1d5db'; gCtx.setLineDash([]); 
                gCtx.strokeRect(x, yOffset, cellSize, cellSize);
                gCtx.strokeRect(x, yOffset + cellSize, cellSize, cellSize);
                
                gCtx.beginPath(); gCtx.setLineDash([3, 3]); gCtx.strokeStyle = '#e5e7eb';
                const step = cellSize / 4;
                for (let j = 1; j < 4; j++) {
                    gCtx.moveTo(x + (j * step), yOffset + cellSize); gCtx.lineTo(x + (j * step), yOffset + (cellSize * 2));
                    gCtx.moveTo(x, yOffset + cellSize + (j * step)); gCtx.lineTo(x + cellSize, yOffset + cellSize + (j * step));
                }
                gCtx.stroke();

                gCtx.textAlign = 'center'; gCtx.textBaseline = 'middle';
                gCtx.font = `${cellSize * 0.65}px ${font}`;
                gCtx.fillStyle = '#111827'; gCtx.fillText(text[i], x + cellSize/2, yOffset + cellSize/2);
                gCtx.fillStyle = 'rgba(0,0,0,0.03)'; gCtx.fillText(text[i], x + cellSize/2, yOffset + cellSize*1.5);
            }
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - rect.left, y: clientY - rect.top };
        }

        canvas.addEventListener('touchstart', (e) => {
            const p = getPos(e);
            if (isInsideWriteArea(p.x, p.y)) { e.preventDefault(); isDrawing = true; saveHistory(); [lastX, lastY] = [p.x, p.y]; }
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
            if (!isDrawing) return;
            const p = getPos(e);
            if (isInsideWriteArea(p.x, p.y)) { e.preventDefault(); ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(p.x, p.y); ctx.strokeStyle = customColor.value; ctx.lineWidth = strokeRange.value; ctx.stroke(); [lastX, lastY] = [p.x, p.y]; }
            else { isDrawing = false; }
        }, { passive: false });
        canvas.addEventListener('touchend', () => isDrawing = false);
        canvas.addEventListener('mousedown', (e) => { const p = getPos(e); if (isInsideWriteArea(p.x, p.y)) { isDrawing = true; saveHistory(); [lastX, lastY] = [p.x, p.y]; } });
        canvas.addEventListener('mousemove', (e) => { if (!isDrawing) return; const p = getPos(e); if (isInsideWriteArea(p.x, p.y)) { ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(p.x, p.y); ctx.strokeStyle = customColor.value; ctx.lineWidth = strokeRange.value; ctx.stroke(); [lastX, lastY] = [p.x, p.y]; } else { isDrawing = false; } });
        window.addEventListener('mouseup', () => isDrawing = false);

        analyzeBtn.onclick = () => {
            const originalText = inputText.value; if (!originalText.trim()) return;
            const containerWidth = container.clientWidth - (padding * 2);
            const charsPerLine = Math.max(1, Math.floor(containerWidth / cellSize));
            const font = fontSelect.value;
            const offCanvas = document.createElement('canvas'); offCanvas.width = canvas.width; offCanvas.height = canvas.height;
            const oCtx = offCanvas.getContext('2d'); oCtx.font = `${cellSize * 0.65}px ${font}`; oCtx.textAlign = 'center'; oCtx.textBaseline = 'middle';
            let totalMatchScore = 0, validChars = 0;
            for (let i = 0; i < originalText.length; i++) {
                const char = originalText[i]; if (char.trim().length === 0) continue;
                const x = padding + ((i % charsPerLine) * cellSize);
                const y = padding + (Math.floor(i / charsPerLine) * ((cellSize * 2) + lineSpacing)) + cellSize;
                oCtx.clearRect(x, y, cellSize, cellSize); oCtx.fillText(char, x + cellSize / 2, y + cellSize / 2);
                const answerData = oCtx.getImageData(x, y, cellSize, cellSize).data;
                const userData = ctx.getImageData(x, y, cellSize, cellSize).data;
                let match = 0, answerPixels = 0, userPixels = 0;
                for (let j = 3; j < answerData.length; j += 4) { if (answerData[j] > 20) answerPixels++; if (userData[j] > 20) userPixels++; if (answerData[j] > 20 && userData[j] > 20) match++; }
                if (userPixels > 10) { totalMatchScore += Math.min((match / answerPixels) * 100, 100); validChars++; }
            }
            currentAccuracy = validChars > 0 ? Math.round(totalMatchScore / validChars) : 0;
            document.getElementById('percentVal').textContent = currentAccuracy + '%';
            document.getElementById('scoreDisplay').classList.remove('hidden');
            document.getElementById('modalScoreText').textContent = `í‰ê·  ì •í™•ë„: ${currentAccuracy}%`;
            infoModal.style.display = 'flex';
        };

        submitInfo.onclick = async () => {
            const sid = document.getElementById('studentId').value.trim();
            const sname = document.getElementById('studentName').value.trim();
            if (!sid || !sname) { alert("í•™ë²ˆê³¼ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }
            const btnText = document.getElementById('btnText'); btnText.innerHTML = '<span class="loading-spinner"></span>ê¸°ë¡ ì¤‘...';
            try {
                await fetch(scriptURL, { method: 'POST', mode: 'no-cors', body: JSON.stringify({ studentId: sid, name: sname, text: inputText.value, accuracy: currentAccuracy }) });
                alert("ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤!"); infoModal.style.display = 'none';
            } catch (e) { alert("ì˜¤ë¥˜ ë°œìƒ"); }
            btnText.innerText = 'ì‹œíŠ¸ì— ê¸°ë¡í•˜ê¸°';
        };

        document.getElementById('cancelModal').onclick = () => infoModal.style.display = 'none';
        clearBtn.onclick = () => { if(confirm("ì´ˆê¸°í™”?")) { ctx.clearRect(0, 0, canvas.width, canvas.height); history = []; document.getElementById('scoreDisplay').classList.add('hidden'); } };
        undoBtn.onclick = undo;
        inputText.oninput = initCanvas;
        fontSelect.onchange = initCanvas;
        window.onresize = initCanvas;
        window.onload = initCanvas;
        // ì €ì¥ ë²„íŠ¼ ê¸°ëŠ¥ ì¶”ê°€
        document.getElementById('downloadBtn').onclick = () => {
           // ì„ì‹œ ìº”ë²„ìŠ¤ë¥¼ ë§Œë“¤ì–´ ë°°ê²½ê³¼ ê°€ì´ë“œ, ê¸€ì”¨ë¥¼ í•©ì¹©ë‹ˆë‹¤.
           const downloadCanvas = document.createElement('canvas');
           downloadCanvas.width = canvas.width;
           downloadCanvas.height = canvas.height;
           const dCtx = downloadCanvas.getContext('2d');

           // 1. ë°°ê²½ìƒ‰ (í°ìƒ‰) ì±„ìš°ê¸°
           dCtx.fillStyle = "#ffffff";
           dCtx.fillRect(0, 0, downloadCanvas.width, downloadCanvas.height);

           // 2. ê°€ì´ë“œ ë ˆì´ì–´(ì ì„  ë° ê°€ì´ë“œ ê¸€ì) ê·¸ë¦¬ê¸°
           dCtx.drawImage(guideCanvas, 0, 0);

           // 3. ì‚¬ìš©ìê°€ ì“´ ê¸€ì”¨ ê·¸ë¦¬ê¸°
           dCtx.drawImage(canvas, 0, 0);

           // 4. ë‹¤ìš´ë¡œë“œ ë§í¬ ìƒì„± ë° ì‹¤í–‰
           const link = document.createElement('a');
           link.download = `ì†ê¸€ì”¨ì—°ìŠµ_${new Date().getTime()}.png`;
           link.href = downloadCanvas.toDataURL('image/png');
           link.click();
       };
    </script>
</body>
</html>

